CREATE APPLICATION ROLE IF NOT EXISTS APP_PUBLIC;

------- CREATE SCHEMAS -------
CREATE SCHEMA IF NOT EXISTS CORE;
GRANT USAGE ON SCHEMA CORE TO APPLICATION ROLE APP_PUBLIC;

CREATE SCHEMA IF NOT EXISTS CONFIGURATION;
GRANT USAGE, MODIFY,CREATE TABLE ON SCHEMA CONFIGURATION TO APPLICATION ROLE APP_PUBLIC;

CREATE SCHEMA IF NOT EXISTS AGGREGATED_REPORTS;
GRANT  ALL PRIVILEGES ON SCHEMA AGGREGATED_REPORTS TO APPLICATION ROLE APP_PUBLIC;

CREATE SCHEMA IF NOT EXISTS CAMPAIGN_INTELLIGENCE_COMBINED;
GRANT USAGE, MODIFY,CREATE TABLE, CREATE DYNAMIC TABLE, CREATE PROCEDURE ON SCHEMA CAMPAIGN_INTELLIGENCE_COMBINED TO APPLICATION ROLE APP_PUBLIC;

CREATE SCHEMA IF NOT EXISTS STANDARDIZE_MODEL;
GRANT USAGE, MODIFY,CREATE TABLE, CREATE VIEW, CREATE DYNAMIC TABLE ON SCHEMA STANDARDIZE_MODEL TO APPLICATION ROLE APP_PUBLIC;

CREATE SCHEMA IF NOT EXISTS USER_SETTINGS;
GRANT USAGE, CREATE PROCEDURE ON SCHEMA USER_SETTINGS TO APPLICATION ROLE APP_PUBLIC;

CREATE SCHEMA IF NOT EXISTS LLM;
GRANT USAGE, MODIFY, CREATE TABLE ON SCHEMA LLM TO APPLICATION ROLE APP_PUBLIC;

-- Chat bot assistant files
CREATE STAGE LLM.SEMANTIC_MODEL
    DIRECTORY = (ENABLE = TRUE)
    COMMENT = 'Used for holding semantic models used in the chat bot Marketing assitant.';
GRANT READ, WRITE ON STAGE LLM.SEMANTIC_MODEL TO APPLICATION ROLE APP_PUBLIC;

CREATE STAGE LLM.CONFIGURATION
    DIRECTORY = (ENABLE = TRUE)
    COMMENT = 'Used for holding config file used in the chat bot Data Engineering assistant.';
GRANT READ, WRITE ON STAGE LLM.CONFIGURATION TO APPLICATION ROLE APP_PUBLIC;

-- Create Streamlit app
CREATE OR REPLACE STREAMLIT CORE.MARKETING_DATA_FOUNDATION
  FROM '/streamlit'
  MAIN_FILE = '/home.py'
;
GRANT USAGE ON STREAMLIT CORE.MARKETING_DATA_FOUNDATION TO APPLICATION ROLE APP_PUBLIC;


CREATE OR REPLACE TABLE CONFIGURATION.API
(
    NAME          VARCHAR(255),
    ENDPOINT      VARCHAR(255),
    VERSION       VARCHAR(255),
    MODEL         VARCHAR(255)
) COMMENT = 'Contains APIs connection information';
GRANT SELECT, INSERT, DELETE, TRUNCATE ON TABLE CONFIGURATION.API TO APPLICATION ROLE APP_PUBLIC;

CREATE OR REPLACE TABLE LLM.ASSISTANT
(
    ID            VARCHAR(255),
    NAME          VARCHAR(255),
    SYS_PROMPT    VARCHAR,
    USER          VARCHAR,
    ASSISTANT     VARCHAR,
    CHAT          VARIANT
) COMMENT = 'Contains history on llm assistants conversations';
GRANT SELECT, INSERT, DELETE, TRUNCATE, UPDATE  ON TABLE LLM.ASSISTANT TO APPLICATION ROLE APP_PUBLIC;

------- CREATE TABLES -------

--- USER_SETTINGS SCHEMA ---

-- EXISTING SOURCES TABLE
CREATE OR REPLACE TABLE USER_SETTINGS.EXISTING_SOURCES
(
    PROVIDER_ID         INTEGER,
    CONNECTOR_ID        INTEGER,
    DATABASE            VARCHAR(255),
    SCHEMA              VARCHAR(255),
    CREATED_DATE        TIMESTAMP_NTZ
) COMMENT = 'Contains existing sources made by user.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE USER_SETTINGS.EXISTING_SOURCES TO APPLICATION ROLE APP_PUBLIC;

--- CONFIGURATION SCHEMA ---

-- TARGET COLLECTION TABLE
CREATE OR REPLACE TABLE CONFIGURATION.TARGET_COLLECTION
(
    ID                         INTEGER,
    TARGET_COLLECTION_NAME     VARCHAR(255),
    VERSION                    VARCHAR(255),
    LAST_UPDATED_TIMESTAMP     TIMESTAMP_NTZ
) COMMENT = 'Contains available target collections.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.TARGET_COLLECTION TO APPLICATION ROLE APP_PUBLIC;

-- TARGET ENTITY TABLE
CREATE OR REPLACE TABLE CONFIGURATION.TARGET_ENTITY
(
    TARGET_COLLECTION_ID     INTEGER,
    VERSION                  VARCHAR(255),
    TARGET_ENTITY_NAME       VARCHAR(255),
    ID                       INTEGER,
    LAST_UPDATED_TIMESTAMP   TIMESTAMP_NTZ
) COMMENT = 'Contains available target entities.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.TARGET_ENTITY TO APPLICATION ROLE APP_PUBLIC;

-- TARGET ENTITY ATTRIBUTE TABLE
CREATE OR REPLACE TABLE CONFIGURATION.TARGET_ENTITY_ATTRIBUTE
(
    ID                            INTEGER,
    VERSION                       VARCHAR(255),
    TARGET_ENTITY_ID              INTEGER,
    TARGET_ENTITY_ATTRIBUTE_NAME  VARCHAR(255),
    TARGET_ATTRIBUTE_PROPERTIES   OBJECT,
    LAST_UPDATED_TIMESTAMP        TIMESTAMP_NTZ
) COMMENT = 'Contains available target entity attributes.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.TARGET_ENTITY_ATTRIBUTE TO APPLICATION ROLE APP_PUBLIC;

-- SOURCE COLLECTIONS TABLE
CREATE OR REPLACE TABLE CONFIGURATION.SOURCE_COLLECTION
(
    ID                            INTEGER,
    SOURCE_COLLECTION_NAME        VARCHAR(255),
    TARGET_COLLECTION_ID          INTEGER,
    VERSION                       VARCHAR(255),
    TARGET_ENTITY_ID              INTEGER,
    CUSTOM_SQL                    VARCHAR(255),
    USE_CUSTOM_SQL                VARCHAR(255),
    GENERATED_MAPPING_TABLE       VARCHAR(255),
    REFRESH_FREQUENCY             VARCHAR(255),
    PROVIDER_ID                   INTEGER,
    CONNECTOR_ID                  INTEGER,
    LAST_UPDATED_TIMESTAMP        TIMESTAMP_NTZ
) COMMENT = 'Contains available source collections.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.SOURCE_COLLECTION TO APPLICATION ROLE APP_PUBLIC;

-- SOURCE COLLECTION FILTER CONDITION TABLE
CREATE OR REPLACE TABLE CONFIGURATION.SOURCE_COLLECTION_FILTER_CONDITION
(
    SOURCE_COLLECTION_ID          INTEGER,
    LEFT_FILTER_EXPRESSION        VARCHAR(255),
    OPERATOR                      VARCHAR(255),
    RIGHT_FILTER_EXPRESSION       VARCHAR(255),
    LAST_UPDATED_TIMESTAMP        TIMESTAMP_NTZ
) COMMENT = 'Contains available source collection filter condition.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.SOURCE_COLLECTION_FILTER_CONDITION TO APPLICATION ROLE APP_PUBLIC;


-- SOURCE ENTITY
CREATE OR REPLACE TABLE CONFIGURATION.SOURCE_ENTITY
(
    ID                            INTEGER,
    SOURCE_COLLECTION_ID          INTEGER,
    SOURCE_ENTITY_NAME            VARCHAR(255),
    ENTITY_FULLY_QUALIFIED_NAME   VARCHAR(255),
    IS_BASE_ENTITY                BOOLEAN,
    JOIN_FROM_SOURCE_ENTITY       VARCHAR(255),
    JOIN_TYPE                     VARCHAR(255),
    LAST_UPDATED_TIMESTAMP        TIMESTAMP_NTZ
) COMMENT = 'Contains available source entities.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.SOURCE_ENTITY TO APPLICATION ROLE APP_PUBLIC;


-- SOURCE ENTITY ATTRIBUTE
CREATE OR REPLACE TABLE CONFIGURATION.SOURCE_ENTITY_ATTRIBUTE
(
    SOURCE_ENTITY_ID              INTEGER,
    SOURCE_COLLECTION_ID          INTEGER,
    SOURCE_ENTITY_ATTRIBUTE_NAME  VARCHAR(255),
    SOURCE_ATTRIBUTE_PROPERTIES   OBJECT,
    INCLUDE_IN_ENTITY             BOOLEAN,
    DERIVED_EXPRESSION            VARCHAR(255),
    AGGREGATION_FUNCTION          VARCHAR(255),
    LAST_UPDATED_TIMESTAMP        TIMESTAMP_NTZ
) COMMENT = 'Contains available source entity attributes.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.SOURCE_ENTITY_ATTRIBUTE TO APPLICATION ROLE APP_PUBLIC;

-- SOURCE TO TARGET MAPPING
CREATE OR REPLACE TABLE CONFIGURATION.SOURCE_TO_TARGET_MAPPING
(
    SOURCE_COLLECTION_ID                 INTEGER,
    GENERATED_MAPPING_TABLE_COLUMN_NAME  VARCHAR(255),
    TARGET_ATTRIBUTE_ID                  INTEGER,
    LAST_UPDATED_TIMESTAMP               TIMESTAMP_NTZ
) COMMENT = 'Contains available source to target mappings.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.SOURCE_TO_TARGET_MAPPING TO APPLICATION ROLE APP_PUBLIC;


-- SOURCE ENTITY JOIN CONDITION
CREATE OR REPLACE TABLE CONFIGURATION.SOURCE_ENTITY_JOIN_CONDITION
(
    SOURCE_COLLECTION_ID                 INTEGER,
    SOURCE_ENTITY_ID                     INTEGER,
    JOIN_FROM_SOURCE_ENTITY_ID           INTEGER,
    OPERATOR                             VARCHAR(255),
    JOIN_TO_ENTITY_ATTRIBUTE_ID          INTEGER,
    LAST_UPDATED_TIMESTAMP               TIMESTAMP_NTZ
) COMMENT = 'Contains available source entity join conditions.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.SOURCE_ENTITY_JOIN_CONDITION TO APPLICATION ROLE APP_PUBLIC;


CREATE OR REPLACE TABLE CONFIGURATION.LOG
(
    IDENTIFIED              INTEGER,
    ACTION                  INTEGER,
    USER                    INTEGER,
    DETAILS                 VARCHAR(255),
    TIMESTAMP               TIMESTAMP_NTZ
) COMMENT = 'Contains logs.';
GRANT SELECT, INSERT, TRUNCATE ON TABLE CONFIGURATION.LOG TO APPLICATION ROLE APP_PUBLIC;



-- PROVIDERS TABLE
CREATE OR REPLACE TABLE CONFIGURATION.PROVIDERS
(
    ID     INTEGER,
    NAME   VARCHAR(255)
) COMMENT = 'Contains available application providers.';
GRANT ALL PRIVILEGES ON TABLE CONFIGURATION.PROVIDERS TO APPLICATION ROLE APP_PUBLIC;

-- CONNECTORS TABLE
CREATE OR REPLACE TABLE CONFIGURATION.CONNECTORS
(
    ID     INTEGER,
    NAME   VARCHAR(255)
) COMMENT = 'Contains available application connectors.';
GRANT ALL PRIVILEGES ON TABLE CONFIGURATION.CONNECTORS TO APPLICATION ROLE APP_PUBLIC;

-- QUERY TEMPLATES

CREATE OR REPLACE TABLE CONFIGURATION.QUERY_TEMPLATES
(
    TEMPLATES VARIANT

);

GRANT ALL PRIVILEGES ON TABLE CONFIGURATION.QUERY_TEMPLATES TO APPLICATION ROLE APP_PUBLIC;

CREATE OR REPLACE TABLE CONFIGURATION.DYNAMIC_TABLES_DEFINITION
(
    NAME    VARCHAR(255),
    COLUMNS VARCHAR(1000)

);

GRANT ALL PRIVILEGES ON TABLE CONFIGURATION.DYNAMIC_TABLES_DEFINITION TO APPLICATION ROLE APP_PUBLIC;


-- CONNECTORS PROVIDERS TABLE
CREATE OR REPLACE TABLE CONFIGURATION.CONNECTOR_PROVIDERS
(
    PROVIDER_ID       INTEGER,
    CONNECTOR_ID      INTEGER,
    DEFAULT_SCHEMA    VARCHAR(255),
    CONNECTOR_URL     VARCHAR(255)
) COMMENT = 'Contains the connector providers information.';
GRANT ALL PRIVILEGES ON TABLE CONFIGURATION.CONNECTOR_PROVIDERS TO APPLICATION ROLE APP_PUBLIC;



-- Cortex API procedure to process text
CREATE PROCEDURE LLM.GET_CHAT_RESPONSE(message VARCHAR, file VARCHAR, file_path VARCHAR)
  RETURNS VARIANT
  LANGUAGE PYTHON
  RUNTIME_VERSION = 3.8
  HANDLER = 'run'
  PACKAGES = ('snowflake')
AS
$$
import _snowflake

def run(session, message, file, file_path):
    query_params = ""
    post_params = ""
    headers = { "Content-Type": "application/json" }
    request_body = {
        "role": "user",
        "content": [{"type": "text", "text": message}],
        "modelPath": file,
    }
    db, schema, stage = file_path.split('.')
    
    response = _snowflake.send_snow_api_request("POST", f"/api/v2/databases/{db}/schemas/{schema}/copilots/{stage}/chats/-/messages", query_params, headers, request_body, post_params, 30000);

    return response
$$;
GRANT USAGE ON PROCEDURE LLM.GET_CHAT_RESPONSE(varchar, varchar, varchar) TO APPLICATION ROLE APP_PUBLIC;

CREATE OR REPLACE PROCEDURE LLM.GET_CHAT_COMPLETE (model VARCHAR, messages VARCHAR)
RETURNS TABLE()
LANGUAGE SQL
AS
DECLARE
  res RESULTSET DEFAULT (SELECT snowflake.cortex.complete(:model, :messages));
BEGIN
  RETURN TABLE(res);
END;
GRANT USAGE ON PROCEDURE LLM.GET_CHAT_COMPLETE(varchar, varchar) TO APPLICATION ROLE APP_PUBLIC;
